import {
  DataBodyCell,
  DisplayBodyRow,
  getSubRows,
  nonNull,
  nonUndefined,
  sum
} from "./chunk-V2MVIZGU.js";
import "./chunk-AYNHEKRI.js";
import {
  derived,
  readable,
  writable
} from "./chunk-SJU5G2EV.js";
import {
  get_store_value
} from "./chunk-PLIYL4DX.js";
import "./chunk-2GBBIY5G.js";
import "./chunk-DWA4UIM3.js";

// node_modules/svelte-keyed/dist/index.js
var getTokens = (key) => {
  let keyWithoutBracket = key.replace(/\[(\d+)\]/g, ".$1");
  if (keyWithoutBracket.startsWith(".")) {
    keyWithoutBracket = keyWithoutBracket.slice(1);
  }
  return keyWithoutBracket.split(".");
};
var getNested = (root, keyTokens) => {
  let current = root;
  for (const key of keyTokens) {
    if (current == null) {
      return void 0;
    }
    current = current[key];
  }
  return current;
};
var clonedWithPrototype = (source) => {
  const clone = Object.create(source);
  Object.assign(clone, source);
  return clone;
};
function keyed(parent, path) {
  const keyTokens = getTokens(path);
  if (keyTokens.some((token) => token === "__proto__")) {
    throw new Error('key cannot include "__proto__"');
  }
  const branchTokens = keyTokens.slice(0, keyTokens.length - 1);
  const leafToken = keyTokens[keyTokens.length - 1];
  const keyedValue = derived(parent, ($parent) => getNested($parent, keyTokens));
  const set = (value) => {
    parent.update(($parent) => {
      if ($parent == null) {
        return $parent;
      }
      const newParent = Array.isArray($parent) ? [...$parent] : clonedWithPrototype($parent);
      getNested(newParent, branchTokens)[leafToken] = value;
      return newParent;
    });
  };
  const update = (fn) => {
    parent.update(($parent) => {
      if ($parent == null) {
        return $parent;
      }
      const newValue = fn(getNested($parent, keyTokens));
      const newParent = Array.isArray($parent) ? [...$parent] : clonedWithPrototype($parent);
      getNested(newParent, branchTokens)[leafToken] = newValue;
      return newParent;
    });
  };
  return {
    subscribe: keyedValue.subscribe,
    set,
    update
  };
}

// node_modules/svelte-headless-table/dist/plugins/addColumnFilters.js
var getFilteredRows = (rows, filterValues, columnOptions) => {
  const $filteredRows = rows.map((row) => {
    const { subRows } = row;
    if (subRows === void 0) {
      return row;
    }
    const filteredSubRows = getFilteredRows(subRows, filterValues, columnOptions);
    const clonedRow = row.clone();
    clonedRow.subRows = filteredSubRows;
    return clonedRow;
  }).filter((row) => {
    var _a;
    if ((((_a = row.subRows) == null ? void 0 : _a.length) ?? 0) !== 0) {
      return true;
    }
    for (const [columnId, columnOption] of Object.entries(columnOptions)) {
      const bodyCell = row.cellForId[columnId];
      if (!bodyCell.isData()) {
        continue;
      }
      const { value } = bodyCell;
      const filterValue = filterValues[columnId];
      if (filterValue === void 0) {
        continue;
      }
      const isMatch = columnOption.fn({ value, filterValue });
      if (!isMatch) {
        return false;
      }
    }
    return true;
  });
  return $filteredRows;
};
var addColumnFilters = ({ serverSide = false } = {}) => ({ columnOptions, tableState }) => {
  const filterValues = writable({});
  const preFilteredRows = writable([]);
  const filteredRows = writable([]);
  const pluginState = { filterValues, preFilteredRows };
  const deriveRows = (rows) => {
    return derived([rows, filterValues], ([$rows, $filterValues]) => {
      preFilteredRows.set($rows);
      if (serverSide) {
        filteredRows.set($rows);
        return $rows;
      }
      const _filteredRows = getFilteredRows($rows, $filterValues, columnOptions);
      filteredRows.set(_filteredRows);
      return _filteredRows;
    });
  };
  return {
    pluginState,
    deriveRows,
    hooks: {
      "thead.tr.th": (headerCell) => {
        const filterValue = keyed(filterValues, headerCell.id);
        const props = derived([], () => {
          var _a;
          const columnOption = columnOptions[headerCell.id];
          if (columnOption === void 0) {
            return void 0;
          }
          filterValue.set(columnOption.initialFilterValue);
          const preFilteredValues = derived(preFilteredRows, ($rows) => {
            if (headerCell.isData()) {
              return $rows.map((row) => {
                const cell = row.cellForId[headerCell.id];
                return cell == null ? void 0 : cell.value;
              });
            }
            return [];
          });
          const values = derived(filteredRows, ($rows) => {
            if (headerCell.isData()) {
              return $rows.map((row) => {
                const cell = row.cellForId[headerCell.id];
                return cell == null ? void 0 : cell.value;
              });
            }
            return [];
          });
          const render = (_a = columnOption.render) == null ? void 0 : _a.call(columnOption, {
            id: headerCell.id,
            filterValue,
            ...tableState,
            values,
            preFilteredRows,
            preFilteredValues
          });
          return { render };
        });
        return { props };
      }
    }
  };
};
var matchFilter = ({ filterValue, value }) => {
  if (filterValue === void 0) {
    return true;
  }
  return filterValue === value;
};
var textPrefixFilter = ({ filterValue, value }) => {
  if (filterValue === "") {
    return true;
  }
  return String(value).toLowerCase().startsWith(String(filterValue).toLowerCase());
};
var numberRangeFilter = ({ filterValue: [min, max], value }) => {
  return (min ?? -Infinity) <= value && value <= (max ?? Infinity);
};

// node_modules/svelte-headless-table/dist/plugins/addColumnOrder.js
var addColumnOrder = ({ initialColumnIdOrder = [], hideUnspecifiedColumns = false } = {}) => () => {
  const columnIdOrder = writable(initialColumnIdOrder);
  const pluginState = { columnIdOrder };
  const deriveFlatColumns = (flatColumns) => {
    return derived([flatColumns, columnIdOrder], ([$flatColumns, $columnIdOrder]) => {
      const _flatColumns = [...$flatColumns];
      const orderedFlatColumns = [];
      $columnIdOrder.forEach((id) => {
        const colIdx = _flatColumns.findIndex((c) => c.id === id);
        orderedFlatColumns.push(..._flatColumns.splice(colIdx, 1));
      });
      if (!hideUnspecifiedColumns) {
        orderedFlatColumns.push(..._flatColumns);
      }
      return orderedFlatColumns;
    });
  };
  return {
    pluginState,
    deriveFlatColumns
  };
};

// node_modules/svelte-headless-table/dist/utils/store.js
var isReadable = (value) => {
  return (value == null ? void 0 : value.subscribe) instanceof Function;
};
var Undefined = readable(void 0);
var arraySetStore = (initial = [], { isEqual = (a, b) => a === b } = {}) => {
  const { subscribe, update, set } = writable(initial);
  const toggle = (item, { clearOthers = false } = {}) => {
    update(($arraySet) => {
      const index = $arraySet.findIndex(($item) => isEqual($item, item));
      if (index === -1) {
        if (clearOthers) {
          return [item];
        }
        return [...$arraySet, item];
      }
      if (clearOthers) {
        return [];
      }
      return [...$arraySet.slice(0, index), ...$arraySet.slice(index + 1)];
    });
  };
  const add = (item) => {
    update(($arraySet) => {
      const index = $arraySet.findIndex(($item) => isEqual($item, item));
      if (index === -1) {
        return [...$arraySet, item];
      }
      return $arraySet;
    });
  };
  const remove = (item) => {
    update(($arraySet) => {
      const index = $arraySet.findIndex(($item) => isEqual($item, item));
      if (index === -1) {
        return $arraySet;
      }
      return [...$arraySet.slice(0, index), ...$arraySet.slice(index + 1)];
    });
  };
  const clear = () => {
    set([]);
  };
  return {
    subscribe,
    update,
    set,
    toggle,
    add,
    remove,
    clear
  };
};
var recordSetStore = (initial = {}) => {
  const withFalseRemoved = (record) => {
    return Object.fromEntries(Object.entries(record).filter(([, v]) => v));
  };
  const { subscribe, update, set } = writable(withFalseRemoved(initial));
  const updateAndRemoveFalse = (fn) => {
    update(($recordSet) => {
      const newRecordSet = fn($recordSet);
      return withFalseRemoved(newRecordSet);
    });
  };
  const toggle = (item) => {
    update(($recordSet) => {
      if ($recordSet[item] === true) {
        delete $recordSet[item];
        return $recordSet;
      }
      return {
        ...$recordSet,
        [item]: true
      };
    });
  };
  const add = (item) => {
    update(($recordSet) => ({
      ...$recordSet,
      [item]: true
    }));
  };
  const addAll = (items) => {
    update(($recordSet) => ({
      ...$recordSet,
      ...Object.fromEntries(items.map((item) => [item, true]))
    }));
  };
  const remove = (item) => {
    update(($recordSet) => {
      delete $recordSet[item];
      return $recordSet;
    });
  };
  const removeAll = (items) => {
    update(($recordSet) => {
      for (const item of items) {
        delete $recordSet[item];
      }
      return $recordSet;
    });
  };
  const clear = () => {
    set({});
  };
  return {
    subscribe,
    update: updateAndRemoveFalse,
    set: (newValue) => updateAndRemoveFalse(() => newValue),
    toggle,
    add,
    addAll,
    remove,
    removeAll,
    clear
  };
};

// node_modules/svelte-headless-table/dist/plugins/addDataExport.js
var getObjectsFromRows = (rows, ids, childrenKey) => {
  return rows.map((row) => {
    const dataObject = Object.fromEntries(ids.map((id) => {
      const cell = row.cellForId[id];
      if (cell.isData()) {
        return [id, cell.value];
      }
      if (cell.isDisplay() && cell.column.data !== void 0) {
        let data = cell.column.data(cell, row.state);
        if (isReadable(data)) {
          data = get_store_value(data);
        }
        return [id, data];
      }
      return [id, null];
    }));
    if (row.subRows !== void 0) {
      dataObject[childrenKey] = getObjectsFromRows(row.subRows, ids, childrenKey);
    }
    return dataObject;
  });
};
var getCsvFromRows = (rows, ids) => {
  const dataLines = rows.map((row) => {
    const line = ids.map((id) => {
      const cell = row.cellForId[id];
      if (cell.isData()) {
        return cell.value;
      }
      if (cell.isDisplay() && cell.column.data !== void 0) {
        let data = cell.column.data(cell, row.state);
        if (isReadable(data)) {
          data = get_store_value(data);
        }
        return data;
      }
      return null;
    });
    return line.join(",");
  });
  const headerLine = ids.join(",");
  return headerLine + "\n" + dataLines.join("\n");
};
var addDataExport = ({ format = "object", childrenKey = "children" } = {}) => ({ tableState, columnOptions }) => {
  const excludedIds = Object.entries(columnOptions).filter(([, option]) => option.exclude === true).map(([columnId]) => columnId);
  const { visibleColumns, rows } = tableState;
  const exportedIds = derived(visibleColumns, ($visibleColumns) => $visibleColumns.map((c) => c.id).filter((id) => !excludedIds.includes(id)));
  const exportedData = derived([rows, exportedIds], ([$rows, $exportedIds]) => {
    switch (format) {
      case "json":
        return JSON.stringify(getObjectsFromRows($rows, $exportedIds, childrenKey));
      case "csv":
        return getCsvFromRows($rows, $exportedIds);
      default:
        return getObjectsFromRows($rows, $exportedIds, childrenKey);
    }
  });
  const pluginState = { exportedData };
  return {
    pluginState
  };
};

// node_modules/svelte-headless-table/dist/plugins/addExpandedRows.js
var withExpandedRows = (row, expandedIds) => {
  if (row.subRows === void 0) {
    return [row];
  }
  if (expandedIds[row.id] !== true) {
    return [row];
  }
  const expandedSubRows = row.subRows.flatMap((subRow) => withExpandedRows(subRow, expandedIds));
  return [row, ...expandedSubRows];
};
var addExpandedRows = ({ initialExpandedIds = {} } = {}) => () => {
  const expandedIds = recordSetStore(initialExpandedIds);
  const getRowState = (row) => {
    var _a;
    const isExpanded = keyed(expandedIds, row.id);
    const canExpand = readable((((_a = row.subRows) == null ? void 0 : _a.length) ?? 0) > 0);
    const subRowExpandedIds = derived(expandedIds, ($expandedIds) => {
      return Object.entries($expandedIds).filter(([id, expanded]) => id.startsWith(`${row.id}>`) && expanded);
    });
    const isAllSubRowsExpanded = derived(subRowExpandedIds, ($subRowExpandedIds) => {
      if (row.subRows === void 0) {
        return true;
      }
      const expandableSubRows = row.subRows.filter((subRow) => subRow.subRows !== void 0);
      return $subRowExpandedIds.length === expandableSubRows.length;
    });
    return {
      isExpanded,
      canExpand,
      isAllSubRowsExpanded
    };
  };
  const pluginState = { expandedIds, getRowState };
  const deriveRows = (rows) => {
    return derived([rows, expandedIds], ([$rows, $expandedIds]) => {
      return $rows.flatMap((row) => {
        return withExpandedRows(row, $expandedIds);
      });
    });
  };
  return {
    pluginState,
    deriveRows
  };
};

// node_modules/svelte-headless-table/dist/plugins/addFlatten.js
var getFlattenedRows = (rows, depth) => {
  if (depth === 0)
    return rows;
  const flattenedRows = [];
  for (const row of rows) {
    if (row.subRows === void 0)
      continue;
    flattenedRows.push(...getFlattenedRows(row.subRows, depth - 1));
  }
  return flattenedRows;
};
var addFlatten = ({ initialDepth = 0 } = {}) => () => {
  const depth = writable(initialDepth);
  const pluginState = { depth };
  const deriveRows = (rows) => {
    return derived([rows, depth], ([$rows, $depth]) => {
      return getFlattenedRows($rows, $depth);
    });
  };
  return {
    pluginState,
    deriveRows,
    hooks: {
      "tbody.tr.td": () => {
        const props = derived([], () => {
          const flatten = ($depth) => {
            depth.set($depth);
          };
          const unflatten = () => flatten(0);
          return { flatten, unflatten };
        });
        return { props };
      }
    }
  };
};

// node_modules/svelte-headless-table/dist/plugins/addGridLayout.js
var addGridLayout = () => ({ tableState }) => {
  const pluginState = {};
  const deriveTableAttrs = (attrs) => {
    return derived([attrs, tableState.visibleColumns], ([$attrs, $visibleColumns]) => {
      return {
        ...$attrs,
        style: {
          display: "grid",
          "grid-template-columns": `repeat(${$visibleColumns.length}, auto)`
        }
      };
    });
  };
  const deriveTableHeadAttrs = (attrs) => {
    return derived(attrs, ($attrs) => {
      return {
        ...$attrs,
        style: {
          display: "contents"
        }
      };
    });
  };
  const deriveTableBodyAttrs = (attrs) => {
    return derived(attrs, ($attrs) => {
      return {
        ...$attrs,
        style: {
          display: "contents"
        }
      };
    });
  };
  return {
    pluginState,
    deriveTableAttrs,
    deriveTableHeadAttrs,
    deriveTableBodyAttrs,
    hooks: {
      "thead.tr": () => {
        const attrs = derived([], () => {
          return {
            style: {
              display: "contents"
            }
          };
        });
        return { attrs };
      },
      "thead.tr.th": (cell) => {
        const attrs = derived([], () => {
          return {
            style: {
              "grid-column": `${cell.colstart + 1} / span ${cell.colspan}`
            }
          };
        });
        return { attrs };
      },
      "tbody.tr": () => {
        const attrs = derived([], () => {
          return {
            style: {
              display: "contents"
            }
          };
        });
        return { attrs };
      }
    }
  };
};

// node_modules/svelte-headless-table/dist/utils/event.js
var isShiftClick = (event) => {
  if (!(event instanceof MouseEvent))
    return false;
  return event.shiftKey;
};

// node_modules/svelte-headless-table/dist/plugins/addGroupBy.js
var getIdPrefix = (id) => {
  const prefixTokens = id.split(">").slice(0, -1);
  if (prefixTokens.length === 0) {
    return "";
  }
  return `${prefixTokens.join(">")}>`;
};
var deepenIdAndDepth = (row, parentId) => {
  var _a;
  row.id = `${parentId}>${row.id}`;
  row.depth = row.depth + 1;
  (_a = row.subRows) == null ? void 0 : _a.forEach((subRow) => deepenIdAndDepth(subRow, parentId));
};
var getGroupedRows = (rows, groupByIds, columnOptions, { repeatCellIds, aggregateCellIds, groupCellIds, allGroupByIds }) => {
  if (groupByIds.length === 0) {
    return rows;
  }
  if (rows.length === 0) {
    return rows;
  }
  const idPrefix = getIdPrefix(rows[0].id);
  const [groupById, ...restIds] = groupByIds;
  const subRowsForGroupOnValue = /* @__PURE__ */ new Map();
  for (const row of rows) {
    const cell = row.cellForId[groupById];
    if (!cell.isData()) {
      break;
    }
    const columnOption = columnOptions[groupById] ?? {};
    const { getGroupOn } = columnOption;
    const groupOnValue = (getGroupOn == null ? void 0 : getGroupOn(cell.value)) ?? cell.value;
    if (typeof groupOnValue === "function" || typeof groupOnValue === "object") {
      console.warn(`Missing \`getGroupOn\` column option to aggregate column "${groupById}" with object values`);
    }
    const subRows = subRowsForGroupOnValue.get(groupOnValue) ?? [];
    subRowsForGroupOnValue.set(groupOnValue, [...subRows, row]);
  }
  const groupedRows = [];
  let groupRowIdx = 0;
  for (const [groupOnValue, subRows] of subRowsForGroupOnValue.entries()) {
    const firstRow = subRows[0];
    const groupRow = new DisplayBodyRow({
      id: `${idPrefix}${groupRowIdx++}`,
      // TODO Differentiate data rows and grouped rows.
      depth: firstRow.depth,
      cells: [],
      cellForId: {}
    });
    const groupRowCellForId = Object.fromEntries(Object.entries(firstRow.cellForId).map(([id, cell]) => {
      if (id === groupById) {
        const newCell2 = new DataBodyCell({
          column: cell.column,
          row: groupRow,
          value: groupOnValue
        });
        return [id, newCell2];
      }
      const columnCells = subRows.map((row) => row.cellForId[id]).filter(nonUndefined);
      if (!columnCells[0].isData()) {
        const clonedCell = columnCells[0].clone();
        clonedCell.row = groupRow;
        return [id, clonedCell];
      }
      const { cell: label, getAggregateValue } = columnOptions[id] ?? {};
      const columnValues = columnCells.map((cell2) => cell2.value);
      const value = getAggregateValue === void 0 ? "" : getAggregateValue(columnValues);
      const newCell = new DataBodyCell({
        column: cell.column,
        row: groupRow,
        value,
        label
      });
      return [id, newCell];
    }));
    const groupRowCells = firstRow.cells.map((cell) => {
      return groupRowCellForId[cell.id];
    });
    groupRow.cellForId = groupRowCellForId;
    groupRow.cells = groupRowCells;
    const groupRowSubRows = subRows.map((subRow) => {
      const clonedSubRow = subRow.clone({ includeCells: true, includeSubRows: true });
      deepenIdAndDepth(clonedSubRow, groupRow.id);
      return clonedSubRow;
    });
    groupRow.subRows = getGroupedRows(groupRowSubRows, restIds, columnOptions, {
      repeatCellIds,
      aggregateCellIds,
      groupCellIds,
      allGroupByIds
    });
    groupedRows.push(groupRow);
    groupRow.cells.forEach((cell) => {
      if (cell.id === groupById) {
        groupCellIds[cell.rowColId()] = true;
      } else {
        aggregateCellIds[cell.rowColId()] = true;
      }
    });
    groupRow.subRows.forEach((subRow) => {
      subRow.parentRow = groupRow;
      subRow.cells.forEach((cell) => {
        if (allGroupByIds.includes(cell.id) && groupCellIds[cell.rowColId()] !== true) {
          repeatCellIds[cell.rowColId()] = true;
        }
      });
    });
  }
  return groupedRows;
};
var addGroupBy = ({ initialGroupByIds = [], disableMultiGroup = false, isMultiGroupEvent = isShiftClick } = {}) => ({ columnOptions }) => {
  const disabledGroupIds = Object.entries(columnOptions).filter(([, option]) => option.disable === true).map(([columnId]) => columnId);
  const groupByIds = arraySetStore(initialGroupByIds);
  const repeatCellIds = writable({});
  const aggregateCellIds = writable({});
  const groupCellIds = writable({});
  const pluginState = {
    groupByIds
  };
  const deriveRows = (rows) => {
    return derived([rows, groupByIds], ([$rows, $groupByIds]) => {
      const $repeatCellIds = {};
      const $aggregateCellIds = {};
      const $groupCellIds = {};
      const $groupedRows = getGroupedRows($rows, $groupByIds, columnOptions, {
        repeatCellIds: $repeatCellIds,
        aggregateCellIds: $aggregateCellIds,
        groupCellIds: $groupCellIds,
        allGroupByIds: $groupByIds
      });
      repeatCellIds.set($repeatCellIds);
      aggregateCellIds.set($aggregateCellIds);
      groupCellIds.set($groupCellIds);
      return $groupedRows;
    });
  };
  return {
    pluginState,
    deriveRows,
    hooks: {
      "thead.tr.th": (cell) => {
        const disabled = disabledGroupIds.includes(cell.id) || !cell.isData();
        const props = derived(groupByIds, ($groupByIds) => {
          const grouped = $groupByIds.includes(cell.id);
          const toggle = (event) => {
            if (!cell.isData())
              return;
            if (disabled)
              return;
            groupByIds.toggle(cell.id, {
              clearOthers: disableMultiGroup || !isMultiGroupEvent(event)
            });
          };
          const clear = () => {
            groupByIds.remove(cell.id);
          };
          return {
            grouped,
            toggle,
            clear,
            disabled
          };
        });
        return { props };
      },
      "tbody.tr.td": (cell) => {
        const props = derived([repeatCellIds, aggregateCellIds, groupCellIds], ([$repeatCellIds, $aggregateCellIds, $groupCellIds]) => {
          return {
            repeated: $repeatCellIds[cell.rowColId()] === true,
            aggregated: $aggregateCellIds[cell.rowColId()] === true,
            grouped: $groupCellIds[cell.rowColId()] === true
          };
        });
        return { props };
      }
    }
  };
};

// node_modules/svelte-headless-table/dist/plugins/addHiddenColumns.js
var addHiddenColumns = ({ initialHiddenColumnIds = [] } = {}) => () => {
  const hiddenColumnIds = writable(initialHiddenColumnIds);
  const pluginState = { hiddenColumnIds };
  const deriveFlatColumns = (flatColumns) => {
    return derived([flatColumns, hiddenColumnIds], ([$flatColumns, $hiddenColumnIds]) => {
      if ($hiddenColumnIds.length === 0) {
        return $flatColumns;
      }
      return $flatColumns.filter((c) => !$hiddenColumnIds.includes(c.id));
    });
  };
  return {
    pluginState,
    deriveFlatColumns
  };
};

// node_modules/svelte-headless-table/dist/plugins/addPagination.js
var MIN_PAGE_SIZE = 1;
var createPageStore = ({ items, initialPageSize, initialPageIndex, serverSide, serverItemCount }) => {
  const pageSize = writable(initialPageSize);
  const updatePageSize = (fn) => {
    pageSize.update(($pageSize) => {
      const newPageSize = fn($pageSize);
      return Math.max(newPageSize, MIN_PAGE_SIZE);
    });
  };
  const setPageSize = (newPageSize) => updatePageSize(() => newPageSize);
  const pageIndex = writable(initialPageIndex);
  function calcPageCountAndLimitIndex([$pageSize, $itemCount]) {
    const $pageCount = Math.ceil($itemCount / $pageSize);
    pageIndex.update(($pageIndex) => {
      if ($pageCount > 0 && $pageIndex >= $pageCount) {
        return $pageCount - 1;
      }
      return $pageIndex;
    });
    return $pageCount;
  }
  let pageCount;
  if (serverSide && serverItemCount != null) {
    pageCount = derived([pageSize, serverItemCount], calcPageCountAndLimitIndex);
  } else {
    const itemCount = derived(items, ($items) => $items.length);
    pageCount = derived([pageSize, itemCount], calcPageCountAndLimitIndex);
  }
  const hasPreviousPage = derived(pageIndex, ($pageIndex) => {
    return $pageIndex > 0;
  });
  const hasNextPage = derived([pageIndex, pageCount], ([$pageIndex, $pageCount]) => {
    return $pageIndex < $pageCount - 1;
  });
  return {
    pageSize: {
      subscribe: pageSize.subscribe,
      update: updatePageSize,
      set: setPageSize
    },
    pageIndex,
    pageCount,
    serverItemCount,
    hasPreviousPage,
    hasNextPage
  };
};
var addPagination = ({ initialPageIndex = 0, initialPageSize = 10, serverSide = false, serverItemCount } = {}) => () => {
  const prePaginatedRows = writable([]);
  const paginatedRows = writable([]);
  const { pageSize, pageIndex, pageCount, hasPreviousPage, hasNextPage } = createPageStore({
    items: prePaginatedRows,
    initialPageIndex,
    initialPageSize,
    serverSide,
    serverItemCount
  });
  const pluginState = {
    pageSize,
    pageIndex,
    pageCount,
    hasPreviousPage,
    hasNextPage
  };
  const derivePageRows = (rows) => {
    return derived([rows, pageSize, pageIndex], ([$rows, $pageSize, $pageIndex]) => {
      prePaginatedRows.set($rows);
      if (serverSide) {
        paginatedRows.set($rows);
        return $rows;
      }
      const startIdx = $pageIndex * $pageSize;
      const _paginatedRows = $rows.slice(startIdx, startIdx + $pageSize);
      paginatedRows.set(_paginatedRows);
      return _paginatedRows;
    });
  };
  return {
    pluginState,
    derivePageRows
  };
};

// node_modules/svelte-headless-table/dist/plugins/addResizedColumns.js
var getDragXPos = (event) => {
  if (event instanceof MouseEvent)
    return event.clientX;
  if (event instanceof TouchEvent)
    return event.targetTouches[0].pageX;
  return 0;
};
var isCellDisabled = (cell, disabledIds) => {
  if (disabledIds.includes(cell.id))
    return true;
  if (cell.isGroup() && cell.ids.every((id) => disabledIds.includes(id))) {
    return true;
  }
  return false;
};
var addResizedColumns = ({ onResizeEnd } = {}) => ({ columnOptions }) => {
  const disabledResizeIds = Object.entries(columnOptions).filter(([, option]) => option.disable === true).map(([columnId]) => columnId);
  const initialWidths = Object.fromEntries(Object.entries(columnOptions).filter(([, option]) => option.initialWidth !== void 0).map(([columnId, { initialWidth }]) => [columnId, initialWidth]));
  const columnsWidthState = writable({
    current: initialWidths,
    start: {}
  });
  const columnWidths = keyed(columnsWidthState, "current");
  const pluginState = { columnWidths };
  const dragStartXPosForId = {};
  const nodeForId = {};
  return {
    pluginState,
    hooks: {
      "thead.tr.th": (cell) => {
        const dblClick = (event) => {
          if (isCellDisabled(cell, disabledResizeIds))
            return;
          const { target } = event;
          if (target === null)
            return;
          event.stopPropagation();
          event.preventDefault();
          if (cell.isGroup()) {
            cell.ids.forEach((id) => {
              const node = nodeForId[id];
              if (node !== void 0) {
                columnWidths.update(($columnWidths) => ({
                  ...$columnWidths,
                  [id]: initialWidths[id]
                }));
              }
            });
          } else {
            const node = nodeForId[cell.id];
            if (node !== void 0) {
              columnWidths.update(($columnWidths) => ({
                ...$columnWidths,
                [cell.id]: initialWidths[cell.id]
              }));
            }
          }
        };
        let tapedTwice = false;
        const checkDoubleTap = (event) => {
          if (!tapedTwice) {
            tapedTwice = true;
            setTimeout(function() {
              tapedTwice = false;
            }, 300);
            return false;
          }
          event.preventDefault();
          dblClick(event);
        };
        const dragStart = (event) => {
          if (isCellDisabled(cell, disabledResizeIds))
            return;
          const { target } = event;
          if (target === null)
            return;
          event.stopPropagation();
          event.preventDefault();
          dragStartXPosForId[cell.id] = getDragXPos(event);
          columnsWidthState.update(($columnsWidthState) => {
            const $updatedState = {
              ...$columnsWidthState,
              start: { ...$columnsWidthState.start }
            };
            if (cell.isGroup()) {
              cell.ids.forEach((id) => {
                $updatedState.start[id] = $columnsWidthState.current[id];
              });
            } else {
              $updatedState.start[cell.id] = $columnsWidthState.current[cell.id];
            }
            return $updatedState;
          });
          if (event instanceof MouseEvent) {
            window.addEventListener("mousemove", dragMove);
            window.addEventListener("mouseup", dragEnd);
          } else {
            window.addEventListener("touchmove", dragMove);
            window.addEventListener("touchend", dragEnd);
          }
        };
        const dragMove = (event) => {
          event.stopPropagation();
          event.preventDefault();
          const deltaWidth = getDragXPos(event) - dragStartXPosForId[cell.id];
          columnsWidthState.update(($columnsWidthState) => {
            const $updatedState = {
              ...$columnsWidthState,
              current: { ...$columnsWidthState.current }
            };
            if (cell.isGroup()) {
              const enabledIds = cell.ids.filter((id) => !disabledResizeIds.includes(id));
              const totalStartWidth = sum(enabledIds.map((id) => $columnsWidthState.start[id]));
              enabledIds.forEach((id) => {
                const startWidth = $columnsWidthState.start[id];
                if (startWidth !== void 0) {
                  $updatedState.current[id] = Math.max(0, startWidth + deltaWidth * (startWidth / totalStartWidth));
                }
              });
            } else {
              const startWidth = $columnsWidthState.start[cell.id];
              const { minWidth = 0, maxWidth } = columnOptions[cell.id] ?? {};
              if (startWidth !== void 0) {
                $updatedState.current[cell.id] = Math.min(Math.max(minWidth, startWidth + deltaWidth), ...maxWidth === void 0 ? [] : [maxWidth]);
              }
            }
            return $updatedState;
          });
        };
        const dragEnd = (event) => {
          event.stopPropagation();
          event.preventDefault();
          if (cell.isGroup()) {
            cell.ids.forEach((id) => {
              const node = nodeForId[id];
              if (node !== void 0) {
                columnWidths.update(($columnWidths) => ({
                  ...$columnWidths,
                  [id]: node.getBoundingClientRect().width
                }));
              }
            });
          } else {
            const node = nodeForId[cell.id];
            if (node !== void 0) {
              columnWidths.update(($columnWidths) => ({
                ...$columnWidths,
                [cell.id]: node.getBoundingClientRect().width
              }));
            }
          }
          onResizeEnd == null ? void 0 : onResizeEnd(event);
          if (event instanceof MouseEvent) {
            window.removeEventListener("mousemove", dragMove);
            window.removeEventListener("mouseup", dragEnd);
          } else {
            window.removeEventListener("touchmove", dragMove);
            window.removeEventListener("touchend", dragEnd);
          }
        };
        const $props = (node) => {
          nodeForId[cell.id] = node;
          if (cell.isFlat()) {
            columnWidths.update(($columnWidths) => ({
              ...$columnWidths,
              [cell.id]: node.getBoundingClientRect().width
            }));
          }
          return {
            destroy() {
              delete nodeForId[cell.id];
            }
          };
        };
        $props.drag = (node) => {
          node.addEventListener("mousedown", dragStart);
          node.addEventListener("touchstart", dragStart);
          return {
            destroy() {
              node.removeEventListener("mousedown", dragStart);
              node.removeEventListener("touchstart", dragStart);
            }
          };
        };
        $props.reset = (node) => {
          node.addEventListener("dblclick", dblClick);
          node.addEventListener("touchend", checkDoubleTap);
          return {
            destroy() {
              node.removeEventListener("dblckick", dblClick);
              node.removeEventListener("touchend", checkDoubleTap);
            }
          };
        };
        $props.disabled = isCellDisabled(cell, disabledResizeIds);
        const props = derived([], () => {
          return $props;
        });
        const attrs = derived(columnWidths, ($columnWidths) => {
          const width = cell.isGroup() ? sum(cell.ids.map((id) => $columnWidths[id])) : $columnWidths[cell.id];
          if (width === void 0) {
            return {};
          }
          const widthPx = `${width}px`;
          return {
            style: {
              width: widthPx,
              "min-width": widthPx,
              "max-width": widthPx,
              "box-sizing": "border-box"
            }
          };
        });
        return { props, attrs };
      },
      "tbody.tr.td": (cell) => {
        const attrs = derived(columnWidths, ($columnWidths) => {
          const width = $columnWidths[cell.id];
          if (width === void 0) {
            return {};
          }
          const widthPx = `${width}px`;
          return {
            style: {
              width: widthPx,
              "min-width": widthPx,
              "max-width": widthPx,
              "box-sizing": "border-box"
            }
          };
        });
        return { attrs };
      }
    }
  };
};

// node_modules/svelte-headless-table/dist/plugins/addSelectedRows.js
var isAllSubRowsSelectedForRow = (row, $selectedDataIds, linkDataSubRows) => {
  if (row.isData()) {
    if (!linkDataSubRows || row.subRows === void 0) {
      return $selectedDataIds[row.dataId] === true;
    }
  }
  if (row.subRows === void 0) {
    return false;
  }
  return row.subRows.every((subRow) => isAllSubRowsSelectedForRow(subRow, $selectedDataIds, linkDataSubRows));
};
var isSomeSubRowsSelectedForRow = (row, $selectedDataIds, linkDataSubRows) => {
  if (row.isData()) {
    if (!linkDataSubRows || row.subRows === void 0) {
      return $selectedDataIds[row.dataId] === true;
    }
  }
  if (row.subRows === void 0) {
    return false;
  }
  return row.subRows.some((subRow) => isSomeSubRowsSelectedForRow(subRow, $selectedDataIds, linkDataSubRows));
};
var writeSelectedDataIds = (row, value, $selectedDataIds, linkDataSubRows) => {
  if (row.isData()) {
    $selectedDataIds[row.dataId] = value;
    if (!linkDataSubRows) {
      return;
    }
  }
  if (row.subRows === void 0) {
    return;
  }
  row.subRows.forEach((subRow) => {
    writeSelectedDataIds(subRow, value, $selectedDataIds, linkDataSubRows);
  });
};
var getRowIsSelectedStore = (row, selectedDataIds, linkDataSubRows) => {
  const { subscribe } = derived(selectedDataIds, ($selectedDataIds) => {
    if (row.isData()) {
      if (!linkDataSubRows) {
        return $selectedDataIds[row.dataId] === true;
      }
      if ($selectedDataIds[row.dataId] === true) {
        return true;
      }
    }
    return isAllSubRowsSelectedForRow(row, $selectedDataIds, linkDataSubRows);
  });
  const update = (fn) => {
    selectedDataIds.update(($selectedDataIds) => {
      const oldValue = isAllSubRowsSelectedForRow(row, $selectedDataIds, linkDataSubRows);
      const $updatedSelectedDataIds = { ...$selectedDataIds };
      writeSelectedDataIds(row, fn(oldValue), $updatedSelectedDataIds, linkDataSubRows);
      if (row.parentRow !== void 0 && row.parentRow.isData()) {
        $updatedSelectedDataIds[row.parentRow.dataId] = isAllSubRowsSelectedForRow(row.parentRow, $updatedSelectedDataIds, linkDataSubRows);
      }
      return $updatedSelectedDataIds;
    });
  };
  const set = (value) => update(() => value);
  return {
    subscribe,
    update,
    set
  };
};
var addSelectedRows = ({ initialSelectedDataIds = {}, linkDataSubRows = true } = {}) => ({ tableState }) => {
  const selectedDataIds = recordSetStore(initialSelectedDataIds);
  const getRowState = (row) => {
    const isSelected = getRowIsSelectedStore(row, selectedDataIds, linkDataSubRows);
    const isSomeSubRowsSelected = derived([isSelected, selectedDataIds], ([$isSelected, $selectedDataIds]) => {
      if ($isSelected)
        return false;
      return isSomeSubRowsSelectedForRow(row, $selectedDataIds, linkDataSubRows);
    });
    const isAllSubRowsSelected = derived(selectedDataIds, ($selectedDataIds) => {
      return isAllSubRowsSelectedForRow(row, $selectedDataIds, linkDataSubRows);
    });
    return {
      isSelected,
      isSomeSubRowsSelected,
      isAllSubRowsSelected
    };
  };
  const _allRowsSelected = derived([tableState.rows, selectedDataIds], ([$rows, $selectedDataIds]) => {
    return $rows.every((row) => {
      if (!row.isData()) {
        return true;
      }
      return $selectedDataIds[row.dataId] === true;
    });
  });
  const setAllRowsSelected = ($allRowsSelected) => {
    if ($allRowsSelected) {
      const $rows = get_store_value(tableState.rows);
      const allDataIds = $rows.map((row) => row.isData() ? row.dataId : null).filter(nonNull);
      selectedDataIds.addAll(allDataIds);
    } else {
      selectedDataIds.clear();
    }
  };
  const allRowsSelected = {
    subscribe: _allRowsSelected.subscribe,
    update(fn) {
      const $allRowsSelected = get_store_value(_allRowsSelected);
      setAllRowsSelected(fn($allRowsSelected));
    },
    set: setAllRowsSelected
  };
  const someRowsSelected = derived([tableState.rows, selectedDataIds], ([$rows, $selectedDataIds]) => {
    return $rows.some((row) => {
      if (!row.isData()) {
        return false;
      }
      return $selectedDataIds[row.dataId] === true;
    });
  });
  const _allPageRowsSelected = derived([tableState.pageRows, selectedDataIds], ([$pageRows, $selectedDataIds]) => {
    return $pageRows.every((row) => {
      if (!row.isData()) {
        return true;
      }
      return $selectedDataIds[row.dataId] === true;
    });
  });
  const setAllPageRowsSelected = ($allPageRowsSelected) => {
    const $pageRows = get_store_value(tableState.pageRows);
    const pageDataIds = $pageRows.map((row) => row.isData() ? row.dataId : null).filter(nonNull);
    if ($allPageRowsSelected) {
      selectedDataIds.addAll(pageDataIds);
    } else {
      selectedDataIds.removeAll(pageDataIds);
    }
  };
  const allPageRowsSelected = {
    subscribe: _allPageRowsSelected.subscribe,
    update(fn) {
      const $allPageRowsSelected = get_store_value(_allPageRowsSelected);
      setAllPageRowsSelected(fn($allPageRowsSelected));
    },
    set: setAllPageRowsSelected
  };
  const somePageRowsSelected = derived([tableState.pageRows, selectedDataIds], ([$pageRows, $selectedDataIds]) => {
    return $pageRows.some((row) => {
      if (!row.isData()) {
        return false;
      }
      return $selectedDataIds[row.dataId] === true;
    });
  });
  const pluginState = {
    selectedDataIds,
    getRowState,
    allRowsSelected,
    someRowsSelected,
    allPageRowsSelected,
    somePageRowsSelected
  };
  return {
    pluginState,
    hooks: {
      "tbody.tr": (row) => {
        const props = derived(selectedDataIds, ($selectedDataIds) => {
          const someSubRowsSelected = isSomeSubRowsSelectedForRow(row, $selectedDataIds, linkDataSubRows);
          const allSubRowsSelected = isAllSubRowsSelectedForRow(row, $selectedDataIds, linkDataSubRows);
          const selected = row.isData() ? $selectedDataIds[row.dataId] === true : allSubRowsSelected;
          return {
            selected,
            someSubRowsSelected,
            allSubRowsSelected
          };
        });
        return { props };
      }
    }
  };
};

// node_modules/svelte-headless-table/dist/utils/compare.js
var compare = (a, b) => {
  if (Array.isArray(a) && Array.isArray(b)) {
    return compareArray(a, b);
  }
  if (typeof a === "number" && typeof b === "number")
    return a - b;
  return a < b ? -1 : a > b ? 1 : 0;
};
var compareArray = (a, b) => {
  const minLength = Math.min(a.length, b.length);
  for (let i = 0; i < minLength; i++) {
    const order = compare(a[i], b[i]);
    if (order !== 0)
      return order;
  }
  return 0;
};

// node_modules/svelte-headless-table/dist/plugins/addSortBy.js
var DEFAULT_TOGGLE_ORDER = ["asc", "desc", void 0];
var createSortKeysStore = (initKeys) => {
  const { subscribe, update, set } = writable(initKeys);
  const toggleId = (id, { multiSort = true, toggleOrder = DEFAULT_TOGGLE_ORDER } = {}) => {
    update(($sortKeys) => {
      const keyIdx = $sortKeys.findIndex((key2) => key2.id === id);
      const key = $sortKeys[keyIdx];
      const order = key == null ? void 0 : key.order;
      const orderIdx = toggleOrder.findIndex((o) => o === order);
      const nextOrderIdx = (orderIdx + 1) % toggleOrder.length;
      const nextOrder = toggleOrder[nextOrderIdx];
      if (!multiSort) {
        if (nextOrder === void 0) {
          return [];
        }
        return [{ id, order: nextOrder }];
      }
      if (keyIdx === -1 && nextOrder !== void 0) {
        return [...$sortKeys, { id, order: nextOrder }];
      }
      if (nextOrder === void 0) {
        return [...$sortKeys.slice(0, keyIdx), ...$sortKeys.slice(keyIdx + 1)];
      }
      return [
        ...$sortKeys.slice(0, keyIdx),
        { id, order: nextOrder },
        ...$sortKeys.slice(keyIdx + 1)
      ];
    });
  };
  const clearId = (id) => {
    update(($sortKeys) => {
      const keyIdx = $sortKeys.findIndex((key) => key.id === id);
      if (keyIdx === -1) {
        return $sortKeys;
      }
      return [...$sortKeys.slice(0, keyIdx), ...$sortKeys.slice(keyIdx + 1)];
    });
  };
  return {
    subscribe,
    update,
    set,
    toggleId,
    clearId
  };
};
var getSortedRows = (rows, sortKeys, columnOptions) => {
  const $sortedRows = [...rows];
  $sortedRows.sort((a, b) => {
    var _a, _b, _c;
    for (const key of sortKeys) {
      const invert = ((_a = columnOptions[key.id]) == null ? void 0 : _a.invert) ?? false;
      const cellA = a.cellForId[key.id];
      const cellB = b.cellForId[key.id];
      let order = 0;
      const compareFn = (_b = columnOptions[key.id]) == null ? void 0 : _b.compareFn;
      const getSortValue = (_c = columnOptions[key.id]) == null ? void 0 : _c.getSortValue;
      if (!cellA.isData()) {
        return 0;
      }
      const valueA = cellA.value;
      const valueB = cellB.value;
      if (compareFn !== void 0) {
        order = compareFn(valueA, valueB);
      } else if (getSortValue !== void 0) {
        const sortValueA = getSortValue(valueA);
        const sortValueB = getSortValue(valueB);
        order = compare(sortValueA, sortValueB);
      } else if (typeof valueA === "string" || typeof valueA === "number") {
        order = compare(valueA, valueB);
      } else if (valueA instanceof Date || valueB instanceof Date) {
        const sortValueA = valueA instanceof Date ? valueA.getTime() : 0;
        const sortValueB = valueB instanceof Date ? valueB.getTime() : 0;
        order = compare(sortValueA, sortValueB);
      }
      if (order !== 0) {
        let orderFactor = 1;
        if (key.order === "desc") {
          orderFactor *= -1;
        }
        if (invert) {
          orderFactor *= -1;
        }
        return order * orderFactor;
      }
    }
    return 0;
  });
  for (let i = 0; i < $sortedRows.length; i++) {
    const { subRows } = $sortedRows[i];
    if (subRows === void 0) {
      continue;
    }
    const sortedSubRows = getSortedRows(subRows, sortKeys, columnOptions);
    const clonedRow = $sortedRows[i].clone();
    clonedRow.subRows = sortedSubRows;
    $sortedRows[i] = clonedRow;
  }
  return $sortedRows;
};
var addSortBy = ({ initialSortKeys = [], disableMultiSort = false, isMultiSortEvent = isShiftClick, toggleOrder, serverSide = false } = {}) => ({ columnOptions }) => {
  const disabledSortIds = Object.entries(columnOptions).filter(([, option]) => option.disable === true).map(([columnId]) => columnId);
  const sortKeys = createSortKeysStore(initialSortKeys);
  const preSortedRows = writable([]);
  const deriveRows = (rows) => {
    return derived([rows, sortKeys], ([$rows, $sortKeys]) => {
      preSortedRows.set($rows);
      if (serverSide) {
        return $rows;
      }
      return getSortedRows($rows, $sortKeys, columnOptions);
    });
  };
  const pluginState = { sortKeys, preSortedRows };
  return {
    pluginState,
    deriveRows,
    hooks: {
      "thead.tr.th": (cell) => {
        const disabled = disabledSortIds.includes(cell.id);
        const props = derived(sortKeys, ($sortKeys) => {
          const key = $sortKeys.find((k) => k.id === cell.id);
          const toggle = (event) => {
            if (!cell.isData())
              return;
            if (disabled)
              return;
            sortKeys.toggleId(cell.id, {
              multiSort: disableMultiSort ? false : isMultiSortEvent(event),
              toggleOrder
            });
          };
          const clear = () => {
            if (!cell.isData())
              return;
            if (disabledSortIds.includes(cell.id))
              return;
            sortKeys.clearId(cell.id);
          };
          return {
            order: key == null ? void 0 : key.order,
            toggle,
            clear,
            disabled
          };
        });
        return { props };
      },
      "tbody.tr.td": (cell) => {
        const props = derived(sortKeys, ($sortKeys) => {
          const key = $sortKeys.find((k) => k.id === cell.id);
          return {
            order: key == null ? void 0 : key.order
          };
        });
        return { props };
      }
    }
  };
};

// node_modules/svelte-headless-table/dist/plugins/addSubRows.js
var withSubRows = (row, getChildren) => {
  const subItems = getChildren(row.original);
  if (subItems === void 0) {
    return row;
  }
  const subRows = getSubRows(subItems, row);
  row.subRows = subRows.map((row2) => withSubRows(row2, getChildren));
  return row;
};
var addSubRows = ({ children }) => () => {
  const getChildren = children instanceof Function ? children : (item) => item[children];
  const deriveRows = (rows) => {
    return derived(rows, ($rows) => {
      return $rows.map((row) => {
        if (row.isData()) {
          return withSubRows(row, getChildren);
        }
        return row;
      });
    });
  };
  return {
    pluginState: {},
    deriveRows
  };
};

// node_modules/svelte-headless-table/dist/plugins/addTableFilter.js
var getFilteredRows2 = (rows, filterValue, columnOptions, { tableCellMatches, fn, includeHiddenColumns }) => {
  const $filteredRows = rows.map((row) => {
    const { subRows } = row;
    if (subRows === void 0) {
      return row;
    }
    const filteredSubRows = getFilteredRows2(subRows, filterValue, columnOptions, {
      tableCellMatches,
      fn,
      includeHiddenColumns
    });
    const clonedRow = row.clone();
    clonedRow.subRows = filteredSubRows;
    return clonedRow;
  }).filter((row) => {
    var _a;
    if ((((_a = row.subRows) == null ? void 0 : _a.length) ?? 0) !== 0) {
      return true;
    }
    const rowCellMatches = Object.values(row.cellForId).map((cell) => {
      const options = columnOptions[cell.id];
      if ((options == null ? void 0 : options.exclude) === true) {
        return false;
      }
      const isHidden = row.cells.find((c) => c.id === cell.id) === void 0;
      if (isHidden && !includeHiddenColumns) {
        return false;
      }
      if (!cell.isData()) {
        return false;
      }
      let value = cell.value;
      if ((options == null ? void 0 : options.getFilterValue) !== void 0) {
        value = options == null ? void 0 : options.getFilterValue(value);
      }
      const matches = fn({ value: String(value), filterValue });
      if (matches) {
        const dataRowColId = cell.dataRowColId();
        if (dataRowColId !== void 0) {
          tableCellMatches[dataRowColId] = matches;
        }
      }
      return matches;
    });
    return rowCellMatches.includes(true);
  });
  return $filteredRows;
};
var addTableFilter = ({ fn = textPrefixFilter, initialFilterValue = "", includeHiddenColumns = false, serverSide = false } = {}) => ({ columnOptions }) => {
  const filterValue = writable(initialFilterValue);
  const preFilteredRows = writable([]);
  const tableCellMatches = recordSetStore();
  const pluginState = { filterValue, preFilteredRows };
  const deriveRows = (rows) => {
    return derived([rows, filterValue], ([$rows, $filterValue]) => {
      preFilteredRows.set($rows);
      tableCellMatches.clear();
      const $tableCellMatches = {};
      const $filteredRows = getFilteredRows2($rows, $filterValue, columnOptions, {
        tableCellMatches: $tableCellMatches,
        fn,
        includeHiddenColumns
      });
      tableCellMatches.set($tableCellMatches);
      if (serverSide) {
        return $rows;
      }
      return $filteredRows;
    });
  };
  return {
    pluginState,
    deriveRows,
    hooks: {
      "tbody.tr.td": (cell) => {
        const props = derived([filterValue, tableCellMatches], ([$filterValue, $tableCellMatches]) => {
          const dataRowColId = cell.dataRowColId();
          return {
            matches: $filterValue !== "" && dataRowColId !== void 0 && ($tableCellMatches[dataRowColId] ?? false)
          };
        });
        return { props };
      }
    }
  };
};
export {
  addColumnFilters,
  addColumnOrder,
  addDataExport,
  addExpandedRows,
  addFlatten,
  addGridLayout,
  addGroupBy,
  addHiddenColumns,
  addPagination,
  addResizedColumns,
  addSelectedRows,
  addSortBy,
  addSubRows,
  addTableFilter,
  createPageStore,
  createSortKeysStore,
  getFlattenedRows,
  getGroupedRows,
  matchFilter,
  numberRangeFilter,
  textPrefixFilter
};
//# sourceMappingURL=svelte-headless-table_plugins.js.map
