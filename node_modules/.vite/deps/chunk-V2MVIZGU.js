import {
  derived
} from "./chunk-SJU5G2EV.js";
import {
  SvelteComponentDev,
  assign,
  component_subscribe,
  compute_rest_props,
  create_slot,
  dispatch_dev,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_slot_changes,
  init,
  safe_not_equal,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-PLIYL4DX.js";
import {
  __publicField
} from "./chunk-DWA4UIM3.js";

// node_modules/svelte-subscribe/dist/derivedKeys.js
var derivedKeys = (storeMap) => {
  const entries = Object.entries(storeMap);
  const keys = entries.map(([key]) => key);
  return derived(entries.map(([, store]) => store), ($stores) => {
    return Object.fromEntries($stores.map((store, idx) => [keys[idx], store]));
  });
};

// node_modules/svelte-subscribe/dist/Subscribe.svelte
var get_default_slot_spread_changes = (dirty) => dirty & /*$values*/
1;
var get_default_slot_changes = (dirty) => ({});
var get_default_slot_context = (ctx) => ({ .../*$values*/
ctx[0] });
function create_fragment(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $values*/
        5)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            get_default_slot_spread_changes(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $values;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Subscribe", slots, ["default"]);
  const values = derivedKeys($$restProps);
  validate_store(values, "values");
  component_subscribe($$self, values, (value) => $$invalidate(0, $values = value));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ derivedKeys, values, $values });
  return [$values, values, $$scope, slots];
}
var Subscribe = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Subscribe",
      options,
      id: create_fragment.name
    });
  }
};
var Subscribe_default = Subscribe;

// node_modules/svelte-headless-table/dist/utils/css.js
var stringifyCss = (style) => {
  return Object.entries(style).map(([name, value]) => `${name}:${value}`).join(";");
};

// node_modules/svelte-headless-table/dist/utils/attributes.js
var mergeAttributes = (a, b) => {
  if (a.style === void 0 && b.style === void 0) {
    return { ...a, ...b };
  }
  return {
    ...a,
    ...b,
    style: {
      ...typeof a.style === "object" ? a.style : {},
      ...typeof b.style === "object" ? b.style : {}
    }
  };
};
var finalizeAttributes = (attrs) => {
  if (attrs.style === void 0 || typeof attrs.style !== "object") {
    return attrs;
  }
  return {
    ...attrs,
    style: stringifyCss(attrs.style)
  };
};

// node_modules/svelte-headless-table/dist/tableComponent.js
var TableComponent = class {
  constructor({ id }) {
    __publicField(this, "id");
    __publicField(this, "attrsForName", {});
    __publicField(this, "propsForName", {});
    __publicField(this, "state");
    this.id = id;
  }
  attrs() {
    return derived(Object.values(this.attrsForName), ($attrsArray) => {
      let $mergedAttrs = {};
      $attrsArray.forEach(($attrs) => {
        $mergedAttrs = mergeAttributes($mergedAttrs, $attrs);
      });
      return finalizeAttributes($mergedAttrs);
    });
  }
  props() {
    return derivedKeys(this.propsForName);
  }
  injectState(state) {
    this.state = state;
  }
  applyHook(pluginName, hook) {
    if (hook.props !== void 0) {
      this.propsForName[pluginName] = hook.props;
    }
    if (hook.attrs !== void 0) {
      this.attrsForName[pluginName] = hook.attrs;
    }
  }
};

// node_modules/svelte-headless-table/dist/bodyCells.js
var BodyCell = class extends TableComponent {
  constructor({ id, row }) {
    super({ id });
    __publicField(this, "row");
    this.row = row;
  }
  attrs() {
    return derived(super.attrs(), ($baseAttrs) => {
      return {
        ...$baseAttrs,
        role: "cell"
      };
    });
  }
  rowColId() {
    return `${this.row.id}:${this.column.id}`;
  }
  dataRowColId() {
    if (!this.row.isData()) {
      return void 0;
    }
    return `${this.row.dataId}:${this.column.id}`;
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isData() {
    return "__data" in this;
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isDisplay() {
    return "__display" in this;
  }
};
var DataBodyCell = class _DataBodyCell extends BodyCell {
  constructor({ row, column, label, value }) {
    super({ id: column.id, row });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__data", true);
    __publicField(this, "column");
    __publicField(this, "label");
    __publicField(this, "value");
    this.column = column;
    this.label = label;
    this.value = value;
  }
  render() {
    if (this.label === void 0) {
      return `${this.value}`;
    }
    if (this.state === void 0) {
      throw new Error("Missing `state` reference");
    }
    return this.label(this, this.state);
  }
  clone() {
    const clonedCell = new _DataBodyCell({
      row: this.row,
      column: this.column,
      label: this.label,
      value: this.value
    });
    return clonedCell;
  }
};
var DisplayBodyCell = class _DisplayBodyCell extends BodyCell {
  constructor({ row, column, label }) {
    super({ id: column.id, row });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__display", true);
    __publicField(this, "column");
    __publicField(this, "label");
    this.column = column;
    this.label = label;
  }
  render() {
    if (this.state === void 0) {
      throw new Error("Missing `state` reference");
    }
    return this.label(this, this.state);
  }
  clone() {
    const clonedCell = new _DisplayBodyCell({
      row: this.row,
      column: this.column,
      label: this.label
    });
    return clonedCell;
  }
};

// node_modules/svelte-headless-table/dist/utils/filter.js
var nonNull = (value) => value !== null;
var nonUndefined = (value) => value !== void 0;

// node_modules/svelte-headless-table/dist/bodyRows.js
var BodyRow = class extends TableComponent {
  constructor({ id, cells, cellForId, depth = 0, parentRow }) {
    super({ id });
    __publicField(this, "cells");
    /**
     * Get the cell with a given column id.
     *
     * **This includes hidden cells.**
     */
    __publicField(this, "cellForId");
    __publicField(this, "depth");
    __publicField(this, "parentRow");
    __publicField(this, "subRows");
    this.cells = cells;
    this.cellForId = cellForId;
    this.depth = depth;
    this.parentRow = parentRow;
  }
  attrs() {
    return derived(super.attrs(), ($baseAttrs) => {
      return {
        ...$baseAttrs,
        role: "row"
      };
    });
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isData() {
    return "__data" in this;
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isDisplay() {
    return "__display" in this;
  }
};
var DataBodyRow = class _DataBodyRow extends BodyRow {
  constructor({ id, dataId, original, cells, cellForId, depth = 0, parentRow }) {
    super({ id, cells, cellForId, depth, parentRow });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__data", true);
    __publicField(this, "dataId");
    __publicField(this, "original");
    this.dataId = dataId;
    this.original = original;
  }
  clone({ includeCells = false, includeSubRows = false } = {}) {
    var _a;
    const clonedRow = new _DataBodyRow({
      id: this.id,
      dataId: this.dataId,
      cellForId: this.cellForId,
      cells: this.cells,
      original: this.original,
      depth: this.depth
    });
    if (includeCells) {
      const clonedCellsForId = Object.fromEntries(Object.entries(clonedRow.cellForId).map(([id, cell]) => {
        const clonedCell = cell.clone();
        clonedCell.row = clonedRow;
        return [id, clonedCell];
      }));
      const clonedCells = clonedRow.cells.map(({ id }) => clonedCellsForId[id]);
      clonedRow.cellForId = clonedCellsForId;
      clonedRow.cells = clonedCells;
    }
    if (includeSubRows) {
      const clonedSubRows = (_a = this.subRows) == null ? void 0 : _a.map((row) => row.clone({ includeCells, includeSubRows }));
      clonedRow.subRows = clonedSubRows;
    } else {
      clonedRow.subRows = this.subRows;
    }
    return clonedRow;
  }
};
var DisplayBodyRow = class _DisplayBodyRow extends BodyRow {
  constructor({ id, cells, cellForId, depth = 0, parentRow }) {
    super({ id, cells, cellForId, depth, parentRow });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__display", true);
  }
  clone({ includeCells = false, includeSubRows = false } = {}) {
    var _a;
    const clonedRow = new _DisplayBodyRow({
      id: this.id,
      cellForId: this.cellForId,
      cells: this.cells,
      depth: this.depth
    });
    clonedRow.subRows = this.subRows;
    if (includeCells) {
      const clonedCellsForId = Object.fromEntries(Object.entries(clonedRow.cellForId).map(([id, cell]) => {
        const clonedCell = cell.clone();
        clonedCell.row = clonedRow;
        return [id, clonedCell];
      }));
      const clonedCells = clonedRow.cells.map(({ id }) => clonedCellsForId[id]);
      clonedRow.cellForId = clonedCellsForId;
      clonedRow.cells = clonedCells;
    }
    if (includeSubRows) {
      const clonedSubRows = (_a = this.subRows) == null ? void 0 : _a.map((row) => row.clone({ includeCells, includeSubRows }));
      clonedRow.subRows = clonedSubRows;
    } else {
      clonedRow.subRows = this.subRows;
    }
    return clonedRow;
  }
};
var getBodyRows = (data, flatColumns, { rowDataId } = {}) => {
  const rows = data.map((item, idx) => {
    const id = idx.toString();
    return new DataBodyRow({
      id,
      dataId: rowDataId !== void 0 ? rowDataId(item, idx) : id,
      original: item,
      cells: [],
      cellForId: {}
    });
  });
  data.forEach((item, rowIdx) => {
    const cells = flatColumns.map((col) => {
      if (col.isData()) {
        const dataCol = col;
        const value = dataCol.getValue(item);
        return new DataBodyCell({
          row: rows[rowIdx],
          column: dataCol,
          label: col.cell,
          value
        });
      }
      if (col.isDisplay()) {
        const displayCol = col;
        return new DisplayBodyCell({
          row: rows[rowIdx],
          column: displayCol,
          label: col.cell
        });
      }
      throw new Error("Unrecognized `FlatColumn` implementation");
    });
    rows[rowIdx].cells = cells;
    flatColumns.forEach((c, colIdx) => {
      rows[rowIdx].cellForId[c.id] = cells[colIdx];
    });
  });
  return rows;
};
var getColumnedBodyRows = (rows, columnIdOrder) => {
  const columnedRows = rows.map((row) => {
    const clonedRow = row.clone();
    clonedRow.cells = [];
    clonedRow.cellForId = {};
    return clonedRow;
  });
  if (rows.length === 0 || columnIdOrder.length === 0)
    return rows;
  rows.forEach((row, rowIdx) => {
    const cells = row.cells.map((cell) => {
      const clonedCell = cell.clone();
      clonedCell.row = columnedRows[rowIdx];
      return clonedCell;
    });
    const visibleCells = columnIdOrder.map((cid) => {
      return cells.find((c) => c.id === cid);
    }).filter(nonUndefined);
    columnedRows[rowIdx].cells = visibleCells;
    cells.forEach((cell) => {
      columnedRows[rowIdx].cellForId[cell.id] = cell;
    });
  });
  return columnedRows;
};
var getSubRows = (subItems, parentRow, { rowDataId } = {}) => {
  const subRows = subItems.map((item, idx) => {
    const id = `${parentRow.id}>${idx}`;
    return new DataBodyRow({
      id,
      dataId: rowDataId !== void 0 ? rowDataId(item, idx) : id,
      original: item,
      cells: [],
      cellForId: {},
      depth: parentRow.depth + 1,
      parentRow
    });
  });
  subItems.forEach((item, rowIdx) => {
    const cellForId = Object.fromEntries(Object.values(parentRow.cellForId).map((cell) => {
      const { column } = cell;
      if (column.isData()) {
        const dataCol = column;
        const value = dataCol.getValue(item);
        return [
          column.id,
          new DataBodyCell({ row: subRows[rowIdx], column, label: column.cell, value })
        ];
      }
      if (column.isDisplay()) {
        return [
          column.id,
          new DisplayBodyCell({ row: subRows[rowIdx], column, label: column.cell })
        ];
      }
      throw new Error("Unrecognized `FlatColumn` implementation");
    }));
    subRows[rowIdx].cellForId = cellForId;
    const cells = parentRow.cells.map((cell) => {
      return cellForId[cell.id];
    });
    subRows[rowIdx].cells = cells;
  });
  return subRows;
};

// node_modules/svelte-headless-table/dist/utils/math.js
var sum = (nums) => nums.reduce((a, b) => a + b, 0);

export {
  Subscribe_default,
  finalizeAttributes,
  TableComponent,
  BodyCell,
  DataBodyCell,
  DisplayBodyCell,
  nonNull,
  nonUndefined,
  BodyRow,
  DataBodyRow,
  DisplayBodyRow,
  getBodyRows,
  getColumnedBodyRows,
  getSubRows,
  sum
};
//# sourceMappingURL=chunk-V2MVIZGU.js.map
