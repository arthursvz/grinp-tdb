import {
  BodyCell,
  BodyRow,
  DataBodyCell,
  DataBodyRow,
  DisplayBodyCell,
  DisplayBodyRow,
  Subscribe_default,
  TableComponent,
  finalizeAttributes,
  getBodyRows,
  getColumnedBodyRows,
  getSubRows,
  nonUndefined,
  sum
} from "./chunk-V2MVIZGU.js";
import "./chunk-AYNHEKRI.js";
import "./chunk-X7HCJ7ZS.js";
import {
  derived,
  readable,
  writable
} from "./chunk-SJU5G2EV.js";
import {
  SvelteComponentDev,
  add_flush_callback,
  assign,
  bind,
  binding_callbacks,
  check_outros,
  claim_component,
  claim_text,
  component_subscribe,
  construct_svelte_component_dev,
  create_component,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  empty,
  ensure_array_like_dev,
  get_spread_object,
  get_spread_update,
  group_outros,
  init,
  insert_hydration_dev,
  mount_component,
  noop,
  onMount,
  safe_not_equal,
  set_data_dev,
  text,
  transition_in,
  transition_out,
  validate_slots,
  validate_store
} from "./chunk-PLIYL4DX.js";
import "./chunk-2GBBIY5G.js";
import {
  __publicField
} from "./chunk-DWA4UIM3.js";

// node_modules/svelte-render/dist/PropsRenderer.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  return child_ctx;
}
function create_else_block(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*props*/
    ctx[2] ?? {}
  ];
  var switch_value = (
    /*config*/
    ctx[1].component
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    if (dirty !== void 0 && dirty & /*props*/
    4) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*props*/
        ctx2[2] ?? {}
      )]));
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    ctx[4](switch_instance);
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*config*/
      2 && switch_value !== (switch_value = /*config*/
      ctx2[1].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          ctx2[4](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*props*/
        4 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*props*/
          ctx2[2] ?? {}
        )]) : {};
        if (dirty & /*$$scope, config*/
        258) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      ctx[4](null);
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(9:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*props*/
    ctx[2] ?? {}
  ];
  var switch_value = (
    /*config*/
    ctx[1].component
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    if (dirty !== void 0 && dirty & /*props*/
    4) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*props*/
        ctx2[2] ?? {}
      )]));
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    ctx[3](switch_instance);
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*config*/
      2 && switch_value !== (switch_value = /*config*/
      ctx2[1].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          ctx2[3](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*props*/
        4 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*props*/
          ctx2[2] ?? {}
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      ctx[3](null);
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(7:0) {#if config.children.length === 0}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let render;
  let current;
  render = new Render_default({
    props: { of: (
      /*child*/
      ctx[5]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(render.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(render.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(render, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const render_changes = {};
      if (dirty & /*config*/
      2) render_changes.of = /*child*/
      ctx2[5];
      render.$set(render_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(render.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(render.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(render, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(11:2) {#each config.children as child}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*config*/
    ctx[1].children
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*config*/
      2) {
        each_value = ensure_array_like_dev(
          /*config*/
          ctx2[1].children
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(10:1) <svelte:component this={config.component} bind:this={instance} {...props ?? {}}>",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*config*/
      ctx2[1].children.length === 0
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_1($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PropsRenderer", slots, []);
  let { instance: instance2 = void 0 } = $$props;
  let { config } = $$props;
  let { props = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (config === void 0 && !("config" in $$props || $$self.$$.bound[$$self.$$.props["config"]])) {
      console.warn("<PropsRenderer> was created without expected prop 'config'");
    }
  });
  const writable_props = ["instance", "config", "props"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<PropsRenderer> was created with unknown prop '${key}'`);
  });
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      instance2 = $$value;
      $$invalidate(0, instance2);
    });
  }
  function switch_instance_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      instance2 = $$value;
      $$invalidate(0, instance2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("instance" in $$props2) $$invalidate(0, instance2 = $$props2.instance);
    if ("config" in $$props2) $$invalidate(1, config = $$props2.config);
    if ("props" in $$props2) $$invalidate(2, props = $$props2.props);
  };
  $$self.$capture_state = () => ({ Render: Render_default, instance: instance2, config, props });
  $$self.$inject_state = ($$props2) => {
    if ("instance" in $$props2) $$invalidate(0, instance2 = $$props2.instance);
    if ("config" in $$props2) $$invalidate(1, config = $$props2.config);
    if ("props" in $$props2) $$invalidate(2, props = $$props2.props);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [instance2, config, props, switch_instance_binding, switch_instance_binding_1];
}
var PropsRenderer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_1, create_fragment, safe_not_equal, { instance: 0, config: 1, props: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PropsRenderer",
      options,
      id: create_fragment.name
    });
  }
  get instance() {
    throw new Error("<PropsRenderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set instance(value) {
    throw new Error("<PropsRenderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get config() {
    throw new Error("<PropsRenderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<PropsRenderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<PropsRenderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<PropsRenderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PropsRenderer_default = PropsRenderer;

// node_modules/svelte-render/dist/store.js
var isReadable = (value) => {
  return (value == null ? void 0 : value.subscribe) instanceof Function;
};
var Undefined = readable(void 0);

// node_modules/svelte-render/dist/ComponentRenderer.svelte
function create_else_block2(ctx) {
  let propsrenderer;
  let updating_instance;
  let current;
  function propsrenderer_instance_binding_1(value) {
    ctx[3](value);
  }
  let propsrenderer_props = {
    config: (
      /*config*/
      ctx[0]
    ),
    props: (
      /*config*/
      ctx[0].props
    )
  };
  if (
    /*instance*/
    ctx[1] !== void 0
  ) {
    propsrenderer_props.instance = /*instance*/
    ctx[1];
  }
  propsrenderer = new PropsRenderer_default({
    props: propsrenderer_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(propsrenderer, "instance", propsrenderer_instance_binding_1));
  const block = {
    c: function create() {
      create_component(propsrenderer.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(propsrenderer.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(propsrenderer, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const propsrenderer_changes = {};
      if (dirty & /*config*/
      1) propsrenderer_changes.config = /*config*/
      ctx2[0];
      if (dirty & /*config*/
      1) propsrenderer_changes.props = /*config*/
      ctx2[0].props;
      if (!updating_instance && dirty & /*instance*/
      2) {
        updating_instance = true;
        propsrenderer_changes.instance = /*instance*/
        ctx2[1];
        add_flush_callback(() => updating_instance = false);
      }
      propsrenderer.$set(propsrenderer_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(propsrenderer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(propsrenderer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(propsrenderer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(27:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let subscribe_1;
  let current;
  subscribe_1 = new Subscribe_default({
    props: {
      props: (
        /*config*/
        ctx[0].props
      ),
      $$slots: {
        default: [
          create_default_slot2,
          ({ props }) => ({ 4: props }),
          ({ props }) => props ? 16 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(subscribe_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(subscribe_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(subscribe_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const subscribe_1_changes = {};
      if (dirty & /*config*/
      1) subscribe_1_changes.props = /*config*/
      ctx2[0].props;
      if (dirty & /*$$scope, config, props, instance*/
      51) {
        subscribe_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      subscribe_1.$set(subscribe_1_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(subscribe_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(subscribe_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(subscribe_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(23:0) {#if isReadable(config.props)}",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let propsrenderer;
  let updating_instance;
  let current;
  function propsrenderer_instance_binding(value) {
    ctx[2](value);
  }
  let propsrenderer_props = {
    config: (
      /*config*/
      ctx[0]
    ),
    props: (
      /*props*/
      ctx[4]
    )
  };
  if (
    /*instance*/
    ctx[1] !== void 0
  ) {
    propsrenderer_props.instance = /*instance*/
    ctx[1];
  }
  propsrenderer = new PropsRenderer_default({
    props: propsrenderer_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(propsrenderer, "instance", propsrenderer_instance_binding));
  const block = {
    c: function create() {
      create_component(propsrenderer.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(propsrenderer.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(propsrenderer, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const propsrenderer_changes = {};
      if (dirty & /*config*/
      1) propsrenderer_changes.config = /*config*/
      ctx2[0];
      if (dirty & /*props*/
      16) propsrenderer_changes.props = /*props*/
      ctx2[4];
      if (!updating_instance && dirty & /*instance*/
      2) {
        updating_instance = true;
        propsrenderer_changes.instance = /*instance*/
        ctx2[1];
        add_flush_callback(() => updating_instance = false);
      }
      propsrenderer.$set(propsrenderer_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(propsrenderer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(propsrenderer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(propsrenderer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(24:1) <Subscribe props={config.props} let:props>",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block2, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*config*/
    1) show_if = null;
    if (show_if == null) show_if = !!isReadable(
      /*config*/
      ctx2[0].props
    );
    if (show_if) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ComponentRenderer", slots, []);
  let { config } = $$props;
  let instance2;
  onMount(function attachEventHandlers() {
    config.eventHandlers.forEach(([type, handler]) => {
      const callbacks = instance2.$$.callbacks[type] ?? [];
      callbacks.push(handler);
      $$invalidate(1, instance2.$$.callbacks[type] = callbacks, instance2);
    });
    return function detachEventHandlers() {
      config.eventHandlers.forEach(([type, handler]) => {
        const callbacks = instance2.$$.callbacks[type];
        const idx = callbacks.findIndex((c) => c === handler);
        callbacks.splice(idx, 1);
      });
    };
  });
  $$self.$$.on_mount.push(function() {
    if (config === void 0 && !("config" in $$props || $$self.$$.bound[$$self.$$.props["config"]])) {
      console.warn("<ComponentRenderer> was created without expected prop 'config'");
    }
  });
  const writable_props = ["config"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<ComponentRenderer> was created with unknown prop '${key}'`);
  });
  function propsrenderer_instance_binding(value) {
    instance2 = value;
    $$invalidate(1, instance2);
  }
  function propsrenderer_instance_binding_1(value) {
    instance2 = value;
    $$invalidate(1, instance2);
  }
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2) $$invalidate(0, config = $$props2.config);
  };
  $$self.$capture_state = () => ({
    onMount,
    Subscribe: Subscribe_default,
    PropsRenderer: PropsRenderer_default,
    isReadable,
    config,
    instance: instance2
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2) $$invalidate(0, config = $$props2.config);
    if ("instance" in $$props2) $$invalidate(1, instance2 = $$props2.instance);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    config,
    instance2,
    propsrenderer_instance_binding,
    propsrenderer_instance_binding_1
  ];
}
var ComponentRenderer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_12, create_fragment2, safe_not_equal, { config: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ComponentRenderer",
      options,
      id: create_fragment2.name
    });
  }
  get config() {
    throw new Error("<ComponentRenderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<ComponentRenderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ComponentRenderer_default = ComponentRenderer;

// node_modules/svelte-render/dist/Render.svelte
function create_else_block3(ctx) {
  let componentrenderer;
  let current;
  componentrenderer = new ComponentRenderer_default({
    props: { config: (
      /*config*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(componentrenderer.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(componentrenderer.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(componentrenderer, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const componentrenderer_changes = {};
      if (dirty & /*config*/
      1) componentrenderer_changes.config = /*config*/
      ctx2[0];
      componentrenderer.$set(componentrenderer_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(componentrenderer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(componentrenderer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(componentrenderer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(13:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*config*/
        ctx[0]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*config*/
        ctx[0]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*config*/
      1) set_data_dev(
        t,
        /*config*/
        ctx2[0]
      );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(11:37) ",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*$readableConfig*/
        ctx[1]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*$readableConfig*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$readableConfig*/
      2) set_data_dev(
        t,
        /*$readableConfig*/
        ctx2[1]
      );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(8:0) {#if isReadable(config)}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block3, create_if_block_1, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*config*/
    1) show_if = null;
    if (show_if == null) show_if = !!isReadable(
      /*config*/
      ctx2[0]
    );
    if (show_if) return 0;
    if (typeof /*config*/
    ctx2[0] !== "object") return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let $readableConfig;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Render", slots, []);
  let { of: config } = $$props;
  const readableConfig = isReadable(config) ? config : Undefined;
  validate_store(readableConfig, "readableConfig");
  component_subscribe($$self, readableConfig, (value) => $$invalidate(1, $readableConfig = value));
  $$self.$$.on_mount.push(function() {
    if (config === void 0 && !("of" in $$props || $$self.$$.bound[$$self.$$.props["of"]])) {
      console.warn("<Render> was created without expected prop 'of'");
    }
  });
  const writable_props = ["of"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Render> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("of" in $$props2) $$invalidate(0, config = $$props2.of);
  };
  $$self.$capture_state = () => ({
    ComponentRenderer: ComponentRenderer_default,
    isReadable,
    Undefined,
    config,
    readableConfig,
    $readableConfig
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2) $$invalidate(0, config = $$props2.config);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [config, $readableConfig, readableConfig];
}
var Render = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment3, safe_not_equal, { of: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Render",
      options,
      id: create_fragment3.name
    });
  }
  get of() {
    throw new Error("<Render>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set of(value) {
    throw new Error("<Render>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Render_default = Render;

// node_modules/svelte-render/dist/createRender.js
var ComponentRenderConfig = class {
  constructor(component, props) {
    __publicField(this, "component");
    __publicField(this, "props");
    __publicField(this, "eventHandlers", []);
    __publicField(this, "children", []);
    this.component = component;
    this.props = props;
  }
  on(type, handler) {
    this.eventHandlers.push([type, handler]);
    return this;
  }
  slot(...children) {
    this.children = children;
    return this;
  }
};
function createRender(component, props) {
  return new ComponentRenderConfig(component, props);
}

// node_modules/svelte-headless-table/dist/columns.js
var Column = class {
  constructor({ header, footer, height, plugins }) {
    __publicField(this, "header");
    __publicField(this, "footer");
    __publicField(this, "height");
    __publicField(this, "plugins");
    this.header = header;
    this.footer = footer;
    this.height = height;
    this.plugins = plugins;
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isFlat() {
    return "__flat" in this;
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isData() {
    return "__data" in this;
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isDisplay() {
    return "__display" in this;
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isGroup() {
    return "__group" in this;
  }
};
var FlatColumn = class extends Column {
  constructor({ header, footer, plugins, id }) {
    super({ header, footer, plugins, height: 1 });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__flat", true);
    __publicField(this, "id");
    this.id = id ?? String(header);
  }
};
var DataColumn = class extends FlatColumn {
  constructor({ header, footer, plugins, cell, accessor, id }) {
    super({ header, footer, plugins, id: "Initialization not complete" });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__data", true);
    __publicField(this, "cell");
    __publicField(this, "accessorKey");
    __publicField(this, "accessorFn");
    this.cell = cell;
    if (accessor instanceof Function) {
      this.accessorFn = accessor;
    } else {
      this.accessorKey = accessor;
    }
    if (id === void 0 && this.accessorKey === void 0 && header === void 0) {
      throw new Error("A column id, string accessor, or header is required");
    }
    const accessorKeyId = typeof this.accessorKey === "string" ? this.accessorKey : null;
    this.id = id ?? accessorKeyId ?? String(header);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getValue(item) {
    if (this.accessorFn !== void 0) {
      return this.accessorFn(item);
    }
    if (this.accessorKey !== void 0) {
      return item[this.accessorKey];
    }
    return void 0;
  }
};
var DisplayColumn = class extends FlatColumn {
  constructor({ header, footer, plugins, id, cell, data }) {
    super({ header, footer, plugins, id });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__display", true);
    __publicField(this, "cell");
    __publicField(this, "data");
    this.cell = cell;
    this.data = data;
  }
};
var GroupColumn = class extends Column {
  constructor({ header, footer, columns, plugins }) {
    const height = Math.max(...columns.map((c) => c.height)) + 1;
    super({ header, footer, height, plugins });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__group", true);
    __publicField(this, "columns");
    __publicField(this, "ids");
    this.columns = columns;
    this.ids = getFlatColumnIds(columns);
  }
};
var getFlatColumnIds = (columns) => columns.flatMap((c) => c.isFlat() ? [c.id] : c.isGroup() ? c.ids : []);
var getFlatColumns = (columns) => {
  return columns.flatMap((c) => c.isFlat() ? [c] : c.isGroup() ? getFlatColumns(c.columns) : []);
};

// node_modules/svelte-headless-table/dist/utils/counter.js
var getCounter = (items) => {
  const result = /* @__PURE__ */ new Map();
  items.forEach((item) => {
    result.set(item, (result.get(item) ?? 0) + 1);
  });
  return result;
};

// node_modules/svelte-headless-table/dist/utils/array.js
var getDuplicates = (items) => {
  return Array.from(getCounter(items).entries()).filter(([, count]) => count !== 1).map(([key]) => key);
};

// node_modules/svelte-headless-table/dist/constants.js
var NBSP = " ";

// node_modules/svelte-headless-table/dist/headerCells.js
var HeaderCell = class extends TableComponent {
  constructor({ id, label, colspan, colstart }) {
    super({ id });
    __publicField(this, "label");
    __publicField(this, "colspan");
    __publicField(this, "colstart");
    this.label = label;
    this.colspan = colspan;
    this.colstart = colstart;
  }
  render() {
    if (this.label instanceof Function) {
      if (this.state === void 0) {
        throw new Error("Missing `state` reference");
      }
      return this.label(this, this.state);
    }
    return this.label;
  }
  attrs() {
    return derived(super.attrs(), ($baseAttrs) => {
      return {
        ...$baseAttrs,
        role: "columnheader",
        colspan: this.colspan
      };
    });
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isFlat() {
    return "__flat" in this;
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isData() {
    return "__data" in this;
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isFlatDisplay() {
    return "__flat" in this && "__display" in this;
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isGroup() {
    return "__group" in this;
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isGroupDisplay() {
    return "__group" in this && "__display" in this;
  }
};
var FlatHeaderCell = class _FlatHeaderCell extends HeaderCell {
  constructor({ id, label, colstart }) {
    super({ id, label, colspan: 1, colstart });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__flat", true);
  }
  clone() {
    return new _FlatHeaderCell({
      id: this.id,
      label: this.label,
      colstart: this.colstart
    });
  }
};
var DataHeaderCell = class _DataHeaderCell extends FlatHeaderCell {
  constructor({ id, label, accessorKey, accessorFn, colstart }) {
    super({ id, label, colstart });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__data", true);
    __publicField(this, "accessorKey");
    __publicField(this, "accessorFn");
    this.accessorKey = accessorKey;
    this.accessorFn = accessorFn;
  }
  clone() {
    return new _DataHeaderCell({
      id: this.id,
      label: this.label,
      accessorFn: this.accessorFn,
      accessorKey: this.accessorKey,
      colstart: this.colstart
    });
  }
};
var FlatDisplayHeaderCell = class _FlatDisplayHeaderCell extends FlatHeaderCell {
  constructor({ id, label = NBSP, colstart }) {
    super({ id, label, colstart });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__display", true);
  }
  clone() {
    return new _FlatDisplayHeaderCell({
      id: this.id,
      label: this.label,
      colstart: this.colstart
    });
  }
};
var GroupHeaderCell = class _GroupHeaderCell extends HeaderCell {
  constructor({ label, ids, allIds, colspan, colstart }) {
    super({ id: `[${ids.join(",")}]`, label, colspan, colstart });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__group", true);
    __publicField(this, "ids");
    __publicField(this, "allId");
    __publicField(this, "allIds");
    this.ids = ids;
    this.allId = `[${allIds.join(",")}]`;
    this.allIds = allIds;
  }
  setIds(ids) {
    this.ids = ids;
    this.id = `[${this.ids.join(",")}]`;
  }
  pushId(id) {
    this.ids = [...this.ids, id];
    this.id = `[${this.ids.join(",")}]`;
  }
  clone() {
    return new _GroupHeaderCell({
      label: this.label,
      ids: this.ids,
      allIds: this.allIds,
      colspan: this.colspan,
      colstart: this.colstart
    });
  }
};
var GroupDisplayHeaderCell = class _GroupDisplayHeaderCell extends GroupHeaderCell {
  constructor({ label = NBSP, ids, allIds, colspan = 1, colstart }) {
    super({ label, ids, allIds, colspan, colstart });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__display", true);
  }
  clone() {
    return new _GroupDisplayHeaderCell({
      label: this.label,
      ids: this.ids,
      allIds: this.allIds,
      colspan: this.colspan,
      colstart: this.colstart
    });
  }
};

// node_modules/svelte-headless-table/dist/utils/matrix.js
var getNullMatrix = (width, height) => {
  const result = [];
  for (let i = 0; i < height; i++) {
    result.push(Array(width).fill(null));
  }
  return result;
};
var getTransposed = (matrix) => {
  const height = matrix.length;
  if (height === 0) {
    return matrix;
  }
  const width = matrix[0].length;
  const result = getNullMatrix(height, width);
  for (let i = 0; i < width; i++) {
    for (let j = 0; j < height; j++) {
      result[i][j] = matrix[j][i];
    }
  }
  return result;
};

// node_modules/svelte-headless-table/dist/headerRows.js
var HeaderRow = class _HeaderRow extends TableComponent {
  constructor({ id, cells }) {
    super({ id });
    __publicField(this, "cells");
    this.cells = cells;
  }
  attrs() {
    return derived(super.attrs(), ($baseAttrs) => {
      return {
        ...$baseAttrs,
        role: "row"
      };
    });
  }
  clone() {
    return new _HeaderRow({
      id: this.id,
      cells: this.cells
    });
  }
};
var getHeaderRows = (columns, flatColumnIds = []) => {
  const rowMatrix = getHeaderRowMatrix(columns);
  let columnMatrix = getTransposed(rowMatrix);
  columnMatrix = getOrderedColumnMatrix(columnMatrix, flatColumnIds);
  populateGroupHeaderCellIds(columnMatrix);
  return headerRowsForRowMatrix(getTransposed(columnMatrix));
};
var getHeaderRowMatrix = (columns) => {
  const maxColspan = sum(columns.map((c) => c.isGroup() ? c.ids.length : 1));
  const maxHeight = Math.max(...columns.map((c) => c.height));
  const rowMatrix = getNullMatrix(maxColspan, maxHeight);
  let cellOffset = 0;
  columns.forEach((c) => {
    const heightOffset = maxHeight - c.height;
    loadHeaderRowMatrix(rowMatrix, c, heightOffset, cellOffset);
    cellOffset += c.isGroup() ? c.ids.length : 1;
  });
  return rowMatrix.map((cells, rowIdx) => cells.map((cell, columnIdx) => {
    var _a;
    if (cell !== null)
      return cell;
    if (rowIdx === maxHeight - 1)
      return new FlatDisplayHeaderCell({ id: columnIdx.toString(), colstart: columnIdx });
    const flatId = ((_a = rowMatrix[maxHeight - 1][columnIdx]) == null ? void 0 : _a.id) ?? columnIdx.toString();
    return new GroupDisplayHeaderCell({ ids: [], allIds: [flatId], colstart: columnIdx });
  }));
};
var loadHeaderRowMatrix = (rowMatrix, column, rowOffset, cellOffset) => {
  if (column.isData()) {
    rowMatrix[rowMatrix.length - 1][cellOffset] = new DataHeaderCell({
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      label: column.header,
      accessorFn: column.accessorFn,
      accessorKey: column.accessorKey,
      id: column.id,
      colstart: cellOffset
    });
    return;
  }
  if (column.isDisplay()) {
    rowMatrix[rowMatrix.length - 1][cellOffset] = new FlatDisplayHeaderCell({
      id: column.id,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      label: column.header,
      colstart: cellOffset
    });
    return;
  }
  if (column.isGroup()) {
    for (let i = 0; i < column.ids.length; i++) {
      rowMatrix[rowOffset][cellOffset + i] = new GroupHeaderCell({
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        label: column.header,
        colspan: 1,
        allIds: column.ids,
        ids: [],
        colstart: cellOffset
      });
    }
    let childCellOffset = 0;
    column.columns.forEach((c) => {
      loadHeaderRowMatrix(rowMatrix, c, rowOffset + 1, cellOffset + childCellOffset);
      childCellOffset += c.isGroup() ? c.ids.length : 1;
    });
    return;
  }
};
var getOrderedColumnMatrix = (columnMatrix, flatColumnIds) => {
  if (flatColumnIds.length === 0) {
    return columnMatrix;
  }
  const orderedColumnMatrix = [];
  flatColumnIds.forEach((key, columnIdx) => {
    const nextColumn = columnMatrix.find((columnCells) => {
      const flatCell = columnCells[columnCells.length - 1];
      if (!flatCell.isFlat()) {
        throw new Error("The last element of each column must be a `FlatHeaderCell`");
      }
      return flatCell.id === key;
    });
    if (nextColumn !== void 0) {
      orderedColumnMatrix.push(nextColumn.map((column) => {
        const clonedColumn = column.clone();
        clonedColumn.colstart = columnIdx;
        return clonedColumn;
      }));
    }
  });
  return orderedColumnMatrix;
};
var populateGroupHeaderCellIds = (columnMatrix) => {
  columnMatrix.forEach((columnCells) => {
    const lastCell = columnCells[columnCells.length - 1];
    if (!lastCell.isFlat()) {
      throw new Error("The last element of each column must be a `FlatHeaderCell`");
    }
    columnCells.forEach((c) => {
      if (c.isGroup()) {
        c.pushId(lastCell.id);
      }
    });
  });
};
var headerRowsForRowMatrix = (rowMatrix) => {
  return rowMatrix.map((rowCells, rowIdx) => {
    return new HeaderRow({ id: rowIdx.toString(), cells: getMergedRow(rowCells) });
  });
};
var getMergedRow = (cells) => {
  if (cells.length === 0) {
    return cells;
  }
  const mergedCells = [];
  let startIdx = 0;
  let endIdx = 1;
  while (startIdx < cells.length) {
    const cell = cells[startIdx].clone();
    if (!cell.isGroup()) {
      mergedCells.push(cell);
      startIdx++;
      continue;
    }
    endIdx = startIdx + 1;
    const ids = [...cell.ids];
    while (endIdx < cells.length) {
      const nextCell = cells[endIdx];
      if (!nextCell.isGroup()) {
        break;
      }
      if (cell.allId !== nextCell.allId) {
        break;
      }
      ids.push(...nextCell.ids);
      endIdx++;
    }
    cell.setIds(ids);
    cell.colspan = endIdx - startIdx;
    mergedCells.push(cell);
    startIdx = endIdx;
  }
  return mergedCells;
};

// node_modules/svelte-headless-table/dist/createViewModel.js
var createViewModel = (table, columns, { rowDataId } = {}) => {
  const { data, plugins } = table;
  const $flatColumns = getFlatColumns(columns);
  const flatColumns = readable($flatColumns);
  const originalRows = derived([data, flatColumns], ([$data, $flatColumns2]) => {
    return getBodyRows($data, $flatColumns2, { rowDataId });
  });
  const _visibleColumns = writable([]);
  const _headerRows = writable();
  const _rows = writable([]);
  const _pageRows = writable([]);
  const _tableAttrs = writable({
    role: "table"
  });
  const _tableHeadAttrs = writable({});
  const _tableBodyAttrs = writable({
    role: "rowgroup"
  });
  const pluginInitTableState = {
    data,
    columns,
    flatColumns: $flatColumns,
    tableAttrs: _tableAttrs,
    tableHeadAttrs: _tableHeadAttrs,
    tableBodyAttrs: _tableBodyAttrs,
    visibleColumns: _visibleColumns,
    headerRows: _headerRows,
    originalRows,
    rows: _rows,
    pageRows: _pageRows
  };
  const pluginInstances = Object.fromEntries(Object.entries(plugins).map(([pluginName, plugin]) => {
    const columnOptions = Object.fromEntries($flatColumns.map((c) => {
      var _a;
      const option = (_a = c.plugins) == null ? void 0 : _a[pluginName];
      if (option === void 0)
        return void 0;
      return [c.id, option];
    }).filter(nonUndefined));
    return [
      pluginName,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      plugin({ pluginName, tableState: pluginInitTableState, columnOptions })
    ];
  }));
  const pluginStates = Object.fromEntries(Object.entries(pluginInstances).map(([key, pluginInstance]) => [
    key,
    pluginInstance.pluginState
  ]));
  const tableState = {
    data,
    columns,
    flatColumns: $flatColumns,
    tableAttrs: _tableAttrs,
    tableHeadAttrs: _tableHeadAttrs,
    tableBodyAttrs: _tableBodyAttrs,
    visibleColumns: _visibleColumns,
    headerRows: _headerRows,
    originalRows,
    rows: _rows,
    pageRows: _pageRows,
    pluginStates
  };
  const deriveTableAttrsFns = Object.values(pluginInstances).map((pluginInstance) => pluginInstance.deriveTableAttrs).filter(nonUndefined);
  let tableAttrs = readable({
    role: "table"
  });
  deriveTableAttrsFns.forEach((fn) => {
    tableAttrs = fn(tableAttrs);
  });
  const finalizedTableAttrs = derived(tableAttrs, ($tableAttrs) => {
    const $finalizedAttrs = finalizeAttributes($tableAttrs);
    _tableAttrs.set($finalizedAttrs);
    return $finalizedAttrs;
  });
  const deriveTableHeadAttrsFns = Object.values(pluginInstances).map((pluginInstance) => pluginInstance.deriveTableBodyAttrs).filter(nonUndefined);
  let tableHeadAttrs = readable({});
  deriveTableHeadAttrsFns.forEach((fn) => {
    tableHeadAttrs = fn(tableHeadAttrs);
  });
  const finalizedTableHeadAttrs = derived(tableHeadAttrs, ($tableHeadAttrs) => {
    const $finalizedAttrs = finalizeAttributes($tableHeadAttrs);
    _tableHeadAttrs.set($finalizedAttrs);
    return $finalizedAttrs;
  });
  const deriveTableBodyAttrsFns = Object.values(pluginInstances).map((pluginInstance) => pluginInstance.deriveTableBodyAttrs).filter(nonUndefined);
  let tableBodyAttrs = readable({
    role: "rowgroup"
  });
  deriveTableBodyAttrsFns.forEach((fn) => {
    tableBodyAttrs = fn(tableBodyAttrs);
  });
  const finalizedTableBodyAttrs = derived(tableBodyAttrs, ($tableBodyAttrs) => {
    const $finalizedAttrs = finalizeAttributes($tableBodyAttrs);
    _tableBodyAttrs.set($finalizedAttrs);
    return $finalizedAttrs;
  });
  const deriveFlatColumnsFns = Object.values(pluginInstances).map((pluginInstance) => pluginInstance.deriveFlatColumns).filter(nonUndefined);
  let visibleColumns = flatColumns;
  deriveFlatColumnsFns.forEach((fn) => {
    visibleColumns = fn(visibleColumns);
  });
  const injectedColumns = derived(visibleColumns, ($visibleColumns) => {
    _visibleColumns.set($visibleColumns);
    return $visibleColumns;
  });
  const columnedRows = derived([originalRows, injectedColumns], ([$originalRows, $injectedColumns]) => {
    return getColumnedBodyRows($originalRows, $injectedColumns.map((c) => c.id));
  });
  const deriveRowsFns = Object.values(pluginInstances).map((pluginInstance) => pluginInstance.deriveRows).filter(nonUndefined);
  let rows = columnedRows;
  deriveRowsFns.forEach((fn) => {
    rows = fn(rows);
  });
  const injectedRows = derived(rows, ($rows) => {
    $rows.forEach((row) => {
      row.injectState(tableState);
      row.cells.forEach((cell) => {
        cell.injectState(tableState);
      });
    });
    Object.entries(pluginInstances).forEach(([pluginName, pluginInstance]) => {
      $rows.forEach((row) => {
        var _a;
        if (((_a = pluginInstance.hooks) == null ? void 0 : _a["tbody.tr"]) !== void 0) {
          row.applyHook(pluginName, pluginInstance.hooks["tbody.tr"](row));
        }
        row.cells.forEach((cell) => {
          var _a2;
          if (((_a2 = pluginInstance.hooks) == null ? void 0 : _a2["tbody.tr.td"]) !== void 0) {
            cell.applyHook(pluginName, pluginInstance.hooks["tbody.tr.td"](cell));
          }
        });
      });
    });
    _rows.set($rows);
    return $rows;
  });
  const derivePageRowsFns = Object.values(pluginInstances).map((pluginInstance) => pluginInstance.derivePageRows).filter(nonUndefined);
  let pageRows = injectedRows;
  derivePageRowsFns.forEach((fn) => {
    pageRows = fn(pageRows);
  });
  const injectedPageRows = derived(pageRows, ($pageRows) => {
    $pageRows.forEach((row) => {
      row.injectState(tableState);
      row.cells.forEach((cell) => {
        cell.injectState(tableState);
      });
    });
    Object.entries(pluginInstances).forEach(([pluginName, pluginInstance]) => {
      $pageRows.forEach((row) => {
        var _a;
        if (((_a = pluginInstance.hooks) == null ? void 0 : _a["tbody.tr"]) !== void 0) {
          row.applyHook(pluginName, pluginInstance.hooks["tbody.tr"](row));
        }
        row.cells.forEach((cell) => {
          var _a2;
          if (((_a2 = pluginInstance.hooks) == null ? void 0 : _a2["tbody.tr.td"]) !== void 0) {
            cell.applyHook(pluginName, pluginInstance.hooks["tbody.tr.td"](cell));
          }
        });
      });
    });
    _pageRows.set($pageRows);
    return $pageRows;
  });
  const headerRows = derived(injectedColumns, ($injectedColumns) => {
    const $headerRows = getHeaderRows(columns, $injectedColumns.map((c) => c.id));
    $headerRows.forEach((row) => {
      row.injectState(tableState);
      row.cells.forEach((cell) => {
        cell.injectState(tableState);
      });
    });
    Object.entries(pluginInstances).forEach(([pluginName, pluginInstance]) => {
      $headerRows.forEach((row) => {
        var _a;
        if (((_a = pluginInstance.hooks) == null ? void 0 : _a["thead.tr"]) !== void 0) {
          row.applyHook(pluginName, pluginInstance.hooks["thead.tr"](row));
        }
        row.cells.forEach((cell) => {
          var _a2;
          if (((_a2 = pluginInstance.hooks) == null ? void 0 : _a2["thead.tr.th"]) !== void 0) {
            cell.applyHook(pluginName, pluginInstance.hooks["thead.tr.th"](cell));
          }
        });
      });
    });
    _headerRows.set($headerRows);
    return $headerRows;
  });
  return {
    tableAttrs: finalizedTableAttrs,
    tableHeadAttrs: finalizedTableHeadAttrs,
    tableBodyAttrs: finalizedTableBodyAttrs,
    visibleColumns: injectedColumns,
    flatColumns: $flatColumns,
    headerRows,
    originalRows,
    rows: injectedRows,
    pageRows: injectedPageRows,
    pluginStates
  };
};

// node_modules/svelte-headless-table/dist/createTable.js
var Table = class {
  constructor(data, plugins) {
    __publicField(this, "data");
    __publicField(this, "plugins");
    this.data = data;
    this.plugins = plugins;
  }
  createColumns(columns) {
    const ids = getFlatColumnIds(columns);
    const duplicateIds = getDuplicates(ids);
    if (duplicateIds.length !== 0) {
      throw new Error(`Duplicate column ids not allowed: "${duplicateIds.join('", "')}"`);
    }
    return columns;
  }
  column(def) {
    return new DataColumn(def);
  }
  group(def) {
    return new GroupColumn(def);
  }
  display(def) {
    return new DisplayColumn(def);
  }
  createViewModel(columns, options) {
    return createViewModel(this, columns, options);
  }
};
var createTable = (data, plugins = {}) => {
  return new Table(data, plugins);
};
export {
  BodyCell,
  BodyRow,
  Column,
  ComponentRenderConfig,
  DataBodyCell,
  DataBodyRow,
  DataColumn,
  DataHeaderCell,
  DisplayBodyCell,
  DisplayBodyRow,
  DisplayColumn,
  FlatColumn,
  FlatDisplayHeaderCell,
  FlatHeaderCell,
  GroupColumn,
  GroupDisplayHeaderCell,
  GroupHeaderCell,
  HeaderCell,
  HeaderRow,
  Render_default as Render,
  Subscribe_default as Subscribe,
  Table,
  createRender,
  createTable,
  getBodyRows,
  getColumnedBodyRows,
  getFlatColumnIds,
  getFlatColumns,
  getSubRows
};
//# sourceMappingURL=svelte-headless-table.js.map
